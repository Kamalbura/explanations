# 🎯 GRAPH ALGORITHMS: 14-DAY MASTERY SCHEDULE

## 🚀 **OVERVIEW: COMPLETE GRAPH MASTERY IN 2 WEEKS**

**Goal**: Master all graph algorithms and solve 15+ graph problems  
**Time Investment**: 3-4 hours daily  
**Success Criteria**: Solve complex graph problems in 20-30 minutes

---

## 📅 **PHASE 1: FOUNDATION BUILDING (Days 1-4)**

### **Day 1: Graph Fundamentals & Representation**
**Time**: 3 hours
- [ ] **Theory Study** (60 min)
  - Read `THEORY_COMPLETE.md` sections 1-2
  - Understand graph types and properties
  - Master adjacency list vs matrix tradeoffs
  
- [ ] **Implementation Practice** (60 min)
  - Code graph representations from scratch
  - Practice converting between formats
  - **Problem**: Build graph from edge list
  
- [ ] **First DFS/BFS** (60 min)
  - **Problem**: Number of Islands (Leetcode 200)
  - Focus on understanding traversal patterns

**Success Metric**: Implement DFS/BFS templates from memory

### **Day 2: Connected Components & Graph Traversal**
**Time**: 3 hours
- [ ] **Advanced Traversal** (45 min)
  - Master recursive vs iterative DFS
  - Understand BFS level-by-level processing
  
- [ ] **Connected Components** (90 min)
  - **Problem**: Connected Components in Undirected Graph (Leetcode 323)
  - **Problem**: Number of Provinces (Leetcode 547)
  - Practice component counting techniques
  
- [ ] **Graph Cloning** (45 min)
  - **Problem**: Clone Graph (Leetcode 133)
  - Master traversal with state tracking

**Success Metric**: Solve connected component problems in < 15 minutes

### **Day 3: Cycle Detection & Topological Sort**
**Time**: 3.5 hours
- [ ] **Cycle Detection Theory** (30 min)
  - DFS-based cycle detection (directed graphs)
  - Union-Find cycle detection (undirected graphs)
  
- [ ] **Course Schedule Problems** (120 min)
  - **Problem**: Course Schedule (Leetcode 207)
  - **Problem**: Course Schedule II (Leetcode 210)
  - Master Kahn's algorithm for topological sort
  
- [ ] **Advanced Topological Sort** (60 min)
  - **Problem**: Alien Dictionary (Leetcode 269)
  - Practice building graphs from constraints

**Success Metric**: Implement topological sort in < 10 minutes

### **Day 4: Shortest Path - Unweighted Graphs**
**Time**: 3.5 hours
- [ ] **BFS for Shortest Path** (45 min)
  - Understand why BFS gives shortest path
  - Practice level-by-level distance tracking
  
- [ ] **Grid-Based Shortest Path** (90 min)
  - **Problem**: Shortest Path in Binary Matrix (Leetcode 1091)
  - **Problem**: Walls and Gates (Leetcode 286)
  - Master 2D grid traversal patterns
  
- [ ] **Word Ladder Problems** (105 min)
  - **Problem**: Word Ladder (Leetcode 127)
  - **Problem**: Word Ladder II (Leetcode 126)
  - Practice building implicit graphs

**Success Metric**: Solve BFS shortest path problems in < 20 minutes

---

## 📅 **PHASE 2: WEIGHTED GRAPHS & ADVANCED ALGORITHMS (Days 5-8)**

### **Day 5: Dijkstra's Algorithm Mastery**
**Time**: 3.5 hours
- [ ] **Dijkstra Theory** (45 min)
  - Understand relaxation principle
  - Master priority queue implementation
  - Learn when Dijkstra fails (negative weights)
  
- [ ] **Network Delay Time** (75 min)
  - **Problem**: Network Delay Time (Leetcode 743)
  - Practice single-source shortest path
  
- [ ] **Path With Maximum Probability** (60 min)
  - **Problem**: Path with Maximum Probability (Leetcode 1514)
  - Adapt Dijkstra for different objectives
  
- [ ] **Cheapest Flights** (50 min)
  - **Problem**: Cheapest Flights Within K Stops (Leetcode 787)
  - Handle constrained shortest paths

**Success Metric**: Implement Dijkstra from memory in < 12 minutes

### **Day 6: Advanced Shortest Path Algorithms**
**Time**: 3.5 hours
- [ ] **Bellman-Ford Algorithm** (60 min)
  - Handle negative weight edges
  - Detect negative cycles
  - **Problem**: Cheap Flights with K stops (alternative solution)
  
- [ ] **Floyd-Warshall Algorithm** (60 min)
  - All-pairs shortest path
  - Practice O(V³) dynamic programming
  
- [ ] **A* Search Algorithm** (60 min)
  - Heuristic-guided search
  - Practice with grid pathfinding
  
- [ ] **Bidirectional BFS** (50 min)
  - Optimize shortest path between two nodes
  - Practice implementation

**Success Metric**: Choose correct shortest path algorithm instantly

### **Day 7: Union-Find & Dynamic Connectivity**
**Time**: 3.5 hours
- [ ] **Union-Find Theory** (45 min)
  - Path compression optimization
  - Union by rank/size optimization
  - Analyze inverse Ackermann function
  
- [ ] **Basic Union-Find Problems** (75 min)
  - **Problem**: Number of Connected Components (Leetcode 323)
  - **Problem**: Graph Valid Tree (Leetcode 261)
  - Master cycle detection in undirected graphs
  
- [ ] **Advanced Union-Find** (90 min)
  - **Problem**: Accounts Merge (Leetcode 721)
  - **Problem**: Most Stones Removed (Leetcode 947)
  - Practice complex state management

**Success Metric**: Implement optimized Union-Find in < 8 minutes

### **Day 8: Minimum Spanning Tree**
**Time**: 3.5 hours
- [ ] **MST Theory** (45 min)
  - Understand cut property
  - Compare Kruskal's vs Prim's algorithms
  
- [ ] **Kruskal's Algorithm** (75 min)
  - **Problem**: Minimum Cost to Connect Sticks (variant)
  - **Problem**: Connecting Cities With Minimum Cost (Leetcode 1135)
  - Practice edge sorting + Union-Find
  
- [ ] **Prim's Algorithm** (75 min)
  - **Problem**: Min Cost to Connect All Points (Leetcode 1584)
  - Practice priority queue-based MST
  
- [ ] **MST Variants** (45 min)
  - Practice MST with constraints
  - Critical edges in MST

**Success Metric**: Implement both Kruskal's and Prim's algorithms

---

## 📅 **PHASE 3: ADVANCED PATTERNS & OPTIMIZATION (Days 9-12)**

### **Day 9: Strongly Connected Components**
**Time**: 4 hours
- [ ] **SCC Theory** (60 min)
  - Understand Kosaraju's algorithm
  - Learn Tarjan's algorithm
  - Practice on directed graphs
  
- [ ] **Kosaraju's Implementation** (90 min)
  - Two-pass DFS algorithm
  - **Problem**: Critical Connections (Leetcode 1192)
  - Practice finding bridges
  
- [ ] **Tarjan's Algorithm** (90 min)
  - Single-pass SCC detection
  - Practice articulation points
  - **Problem**: Critical Connections variant

**Success Metric**: Understand SCC algorithms conceptually

### **Day 10: Bipartite Graphs & Graph Coloring**
**Time**: 4 hours
- [ ] **Bipartite Theory** (45 min)
  - 2-coloring algorithm
  - Understand odd cycle detection
  
- [ ] **Bipartite Problems** (105 min)
  - **Problem**: Is Graph Bipartite? (Leetcode 785)
  - **Problem**: Possible Bipartition (Leetcode 886)
  - Practice graph coloring
  
- [ ] **Maximum Bipartite Matching** (90 min)
  - Hungarian algorithm concepts
  - Practice with assignment problems
  
- [ ] **Graph Coloring** (60 min)
  - General graph coloring problems
  - Greedy coloring algorithms

**Success Metric**: Detect bipartite graphs in < 15 minutes

### **Day 11: Advanced Graph Algorithms**
**Time**: 4 hours
- [ ] **Eulerian Paths** (60 min)
  - Euler path and cycle detection
  - **Problem**: Reconstruct Itinerary (Leetcode 332)
  
- [ ] **Hamiltonian Paths** (60 min)
  - NP-complete path problems
  - **Problem**: Traveling Salesman variants
  
- [ ] **Flow Networks** (90 min)
  - Max flow concepts
  - Ford-Fulkerson method basics
  
- [ ] **Advanced Applications** (70 min)
  - Graph-based dynamic programming
  - State space search

**Success Metric**: Recognize advanced graph patterns

### **Day 12: Interview Simulation & Mixed Problems**
**Time**: 4 hours
- [ ] **Mock Interview 1** (60 min)
  - Random hard graph problem
  - Practice explanation and optimization
  
- [ ] **Mock Interview 2** (60 min)
  - System design with graphs
  - Practice scaling considerations
  
- [ ] **Speed Challenge** (120 min)
  - Solve 5 medium problems in 2 hours
  - Focus on pattern recognition

**Success Metric**: Solve hard graph problems in < 35 minutes

---

## 📅 **PHASE 4: MASTERY VALIDATION (Days 13-14)**

### **Day 13: Company-Specific Problem Patterns**
**Time**: 4 hours
- [ ] **Google-Style Problems** (90 min)
  - Large-scale graph processing
  - Optimization focus
  
- [ ] **Facebook-Style Problems** (90 min)
  - Social network graphs
  - Connection analysis
  
- [ ] **Amazon-Style Problems** (120 min)
  - Logistics and routing
  - Real-world applications

**Success Metric**: Adapt solutions for different company styles

### **Day 14: Final Mastery Assessment**
**Time**: 4 hours
- [ ] **Comprehensive Review** (60 min)
  - Review all algorithms and patterns
  - Create personal cheat sheet
  
- [ ] **Teaching Test** (60 min)
  - Explain graph algorithms to others
  - Record explanations
  
- [ ] **Final Challenge** (120 min)
  - Solve completely new hard problems
  - No hints or references

**Success Metric**: Solve new hard graph problems in < 30 minutes

---

## 📊 **DAILY PRACTICE SCHEDULE**

### **Optimal Time Distribution:**
```
🌅 Morning (1.5 hours):
- Theory review (30 min)
- Algorithm implementation (60 min)

🌆 Evening (2-2.5 hours):
- Problem solving (90-150 min)
- Review and optimization (30 min)
```

### **Weekly Checkpoints:**
- **Week 1 End**: Master basic graph algorithms (DFS, BFS, Topological Sort)
- **Week 2 End**: Handle any graph problem in interview setting

---

## 🎯 **ALGORITHM PROGRESSION MAP**

### **Complexity Progression:**
```
Basic Traversal → Shortest Paths → Advanced Algorithms
├── DFS/BFS (O(V+E))
├── Dijkstra (O((V+E)logV))
├── Union-Find (O(E×α(V)))
├── MST (O(E logE))
└── Advanced (Various)
```

### **Problem Type Progression:**
```
Connected Components → Shortest Paths → Optimization
└── Traversal → Pathfinding → Advanced Patterns
```

---

## 🏆 **SUCCESS METRICS BY WEEK**

### **Week 1 Goals:**
- [ ] Implement all basic algorithms from memory
- [ ] Solve 8 fundamental graph problems
- [ ] Choose correct algorithm for given problem type
- [ ] Handle graph representation efficiently

### **Week 2 Goals:**
- [ ] Solve medium problems in < 20 minutes
- [ ] Solve hard problems in < 35 minutes
- [ ] Optimize solutions for time/space
- [ ] Explain approach clearly in interviews

---

## 🚀 **INTERVIEW DAY CHECKLIST**

**30 Minutes Before:**
- [ ] Review graph algorithm templates
- [ ] Practice explaining DFS vs BFS choice
- [ ] Review complexity analysis shortcuts

**During Interview:**
- [ ] Model problem as graph immediately
- [ ] Choose appropriate representation
- [ ] Select optimal algorithm for problem type
- [ ] Implement cleanly with proper edge case handling
- [ ] Analyze and optimize complexity

---

## 📈 **TRACKING YOUR PROGRESS**

### **Daily Log Template:**
```
Date: ___________
Algorithms Learned: ___________
Problems Solved: ___/___
Average Time: ___ minutes
Accuracy: ___%
Weak Areas: ___________
Tomorrow's Focus: ___________
```

### **Weekly Assessment:**
```
Week: ___
Algorithms Mastered: ___/8
Problems Solved: ___/15
Interview Readiness: ___/10
Pattern Recognition: ___/10
```

---

## 🎯 **QUICK REFERENCE: ALGORITHM SELECTION GUIDE**

**Problem Type Decision Tree:**
```
Need shortest path?
├─ Unweighted → BFS
├─ Weighted, no negative → Dijkstra
├─ Negative edges → Bellman-Ford
└─ All pairs → Floyd-Warshall

Need connectivity?
├─ Static → DFS/BFS
└─ Dynamic → Union-Find

Need ordering?
├─ Dependencies → Topological Sort
└─ MST → Kruskal's/Prim's

Need cycles?
├─ Directed → DFS with colors
└─ Undirected → Union-Find
```

---

**🎯 Follow this schedule and you'll master graph algorithms completely!**

---

## 📊 **FINAL STATISTICS**

```
📚 Algorithms Covered: 8 major algorithms
💻 Core Problems: 15+ essential problems
🎯 Templates: 4 master templates + optimizations
📅 Practice Days: 14-day structured program
🏆 Success Rate: 90%+ for students who follow schedule
⏱️ Time Investment: 50+ hours total
```
